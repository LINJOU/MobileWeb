## 移动前端

#### 1.像素

##### 1.1设备像素(device pixel)--物理像素

 它是物理概念，指的是设备中使用的物理像素(Physic pixel)，单位(**px**)，它是一个**相对绝对单位**。

+ 相对性

  在**不同设备**之间，每1个设备像素所代表的物理长度(如英寸)是**可以变化**。

+ 绝对性

  在**同一设备**上，每1个设备像素所代表的物理长度(如英寸)是**固定不变**。

###### 1.1.1 设备（屏幕）分辨率

设备分辨率的单位就是**设备像素**(**px**)。

在同一个手机或电脑设备上，它的设备像素是固定的，这是厂商在出厂时就设置好了的——即一个设备的分辨率是**固定不变**的。

eg：IPhone6 的分辨率为 1334 * 750，表示屏幕上有 1366 * 750 个物理像素。

##### 1.2 CSS像素(css pixel)--逻辑像素  / 设备独立像素(dip: device independent pixels 设备无关像素)

CSS像素一般用(**px**)作为单位。

CSS像素是Web编程的概念，是一个抽象的单位，指的是CSS样式代码中使用的**逻辑像素**。它是一个**纯相对单位**，相对的是设备像素。

+ 相对性
  + 在**同一**设备，每1个CSS像素所代表的物理像素是可以**变化**
  + 在**不同**设备，每1个CSS像素所代表的物理像素是可以**变化**

在桌面浏览器的100%缩放情况下，css的1个像素往往都是对应着电脑屏幕的1个物理像素。

但实际情况却并非如此，在不同的设备或不同的环境中，尤其是在移动设备，css中的1px所代表的设备物理像素的长度是不同的，**1px 的 CSS 像素并不一定等于 1px 的物理像素**。

决定用几个物理像素去显示 1px 的 CSS 像素**取决于设备像素比**。

##### 1.3 缩放

现代浏览CSS器中实现缩放的方式都是**拉伸CSS像素**，即每设备像素单位代表的长度发生变化，而CSS像素总数字不变。eg：将一个宽为128px的元素放大一倍，元素的宽度并没有从128px变到256px，即元素的宽度（CSS像素总数字）仍为128px不变，但它已经占据了256个设备像素的空间（设备像素单位代表的长度缩小一倍）。

结论：

缩放会引起CSS像素的变化——即引起每个CSS像素所占设备像素的空间（每物理像素单位代表长度）的变化。

+ 页面100%

  CSS像素与设备像素会根据像素密度（DPI&PPI）按一定比例重叠。

  eg：假设1px CSS像素 等于 1px 设备像素

  ![czIM5T.gif](https://z3.ax1x.com/2021/04/26/czIM5T.gif)

+ 页面放大一倍

  CSS像素每1px所占设备像素的空间增加一倍（每物理像素单位代表长度减少一倍）

  eg：假设1px CSS像素 等于 1px 设备像素

  ![czIKaV.gif](https://z3.ax1x.com/2021/04/26/czIKaV.gif)

+ 页面缩小一倍

  CSS像素每1px所占设备像素的空间缩小一倍（每物理像素单位代表长度增加一倍）

  eg：假设1px CSS像素 等于 1px 设备像素

  ![czIuV0.gif](https://z3.ax1x.com/2021/04/26/czIuV0.gif)



**页面缩放比例 **：
$$
页面缩放比例  = \frac{设备像素}{逻辑像素}
$$

##### 1.4 DPI & PPI（屏幕像素密度 / 每英寸单位内像素密度）

+ **DPI**(dots per inch)：为打印机每英寸可以喷的墨汁点数，用于印刷行业中度量空间点的密度。在**Android**中代表屏幕像素密度。
+ **PPI**(pixels per inch)：为屏幕每英寸的像素数量(即在一个对角线长度为1英寸的正方形内所拥有的像素数)，用于度量计算机显示屏上像素的密度。在**iOS**中代表屏幕像素密度。

DPI & PPI越高，代表屏幕能以越高的密度显示图像，即像素数越高，图像越清晰(即通常所说的分辨率越高，图像越清晰)，但同时图片会越小，因系统默认设置缩放比(dpr)越大

**DPI & PPI (屏幕像素密度)计算**
$$
DPI(PPI)  = \sqrt\frac{x^2 + y^2}{s}
$$

+ x：屏幕横向分辨率（**设备像素 px**）
+ y：屏幕纵向分辨率**设备像素**（**设备像素 px**）
+ s：屏幕尺寸(inch / 英寸)

   eg：以IPhone6为例

​	
$$
325.16  = \sqrt\frac{750^2 + 1334^2}{4.7}
$$

##### 	

##### 1.5 DPR (Device Pixel Ratio）设备像素比

在移动端浏览器中以及某些桌面浏览器中，window对象有一个`devicePixelRatio`属性，它的官方的定义为：设备物理像素和逻辑像素的比例。
$$
device Pixel Ratio = \frac{物理像素}{逻辑像素}
$$
DPR(设备像素比)也是密度分界，默认缩放比例（PPI | DPI）

+ 安卓的设备像素比

  |                 | ldpi  | mdpi  | hdpi  | xhdpi(Retina) |
  | --------------- | ----- | ----- | ----- | ------------- |
  | dpi  (像素密度) | >=120 | >=160 | >=240 | >=320         |
  | 默认缩放比      | 0.75  | 1.0   | 1.5   | 2.0           |

  DPI在120-160之间的手机被归为低密度手机，160-240被归为中密度，240-320被归为高密度，320以上被归为超高密度。（Apple——Retina）

  Retina屏(高清屏)：DPR >= 2。
  Retina屏比普通屏清晰很多，就是因为它的像素密度翻了一倍。

+ 获取苹果的设备像素比

  规定密度分界基数为**160**

  

$$
DPR = \frac{PPI}{160}
$$

###### Retina屏幕&普通屏，图片模糊的处理(一倍图、二倍图、三倍图的由来)

Retina屏幕&普通屏幕&图片模糊涉及到**DPR(设备像素比)**这个属性。

+ **普通屏&Retina屏区别：**

  + 相同设备独立像素、尺寸，不同dpr，屏幕的表现：

    + 普通屏：设备独立像素：375 x 667，尺寸：4.7in，dpr：1，物理像素：375 x 667
    + Retina屏：设备独立像素：375 x 667，尺寸：4.7in，dpr：2，物理像素：750 x 1334

    它们的屏幕表现：

    ![gUS4gA.png](https://z3.ax1x.com/2021/05/11/gUS4gA.png)

    在不同的屏幕上，无论是普通屏幕还是retina屏幕，**css像素所呈现的大小是一致的**。不同的是，1个css像素占据的物理像素个数（1 : dpr<sup>2</sup>）。

  + 同一css样式(width & height)在相同设备独立像素、尺寸，不同dpr下的表现

    ```css
    width: 2px;
    heigth: 2px;
    ```

    + 普通屏：dpr为1，1个css像素占据的是1个物理像素。
    + retina屏：dpr为2，1个css像素占据的是4个物理像素。

    ![gUpyxs.png](https://z3.ax1x.com/2021/05/11/gUpyxs.png)

    理解：在相同面积的正方形下，根据dpr,由被切割成dpr<sup>2</sup>个小正方形组成。

+ **图片模糊的处理(一倍图、二倍图、三倍图的由来)**

  + 图片模糊的产生

    图片模糊的产生与**位图像素**相关。

    + **位图像素**

      位图像素是栅格图像（如：png,jpg,gif等）**最小的数据单元**。每一个位图像素都包含着一些自身的显示信息。（如：显示位置，颜色值，透明度等）

    理论上来说，**1个位图像素对应1个物理像素，图片才能达到完美清晰的展示**。

    但在retina屏会出现1个位图像素对应多个物理像素。由于单个位图像素已经是最小的数据单位了，它不能再被进行切割。于是为了能够显示出来，就**只能就近取色**，从而导致所谓的图片模糊问题。

    ![gU9Eo8.png](https://z3.ax1x.com/2021/05/11/gU9Eo8.png)

  + **图片模糊的处理(一倍图、二倍图、三倍图的由来)**

    由于位图像素不够分而产生模糊的情况，解决的办法十分简单，就是使用跟dpr同个倍数大小的图片。

    eg：iphone6（dpr：2），一个200x300的`img`标签，原图就要提供400x600的大小。

    当加载到`img`标签中，浏览器会自动对每1px的css像素减半，依然维持着1:1的css像素:物理像素，不产生模糊。

    [详细：一倍图、二倍图、三倍图的CSS适配](#一倍图、二倍图、三倍图的CSS适配)

  + **普通屏使用两倍的图片会产生色差**

    在普通屏下，1个位图像素对应1个物理像素，而两倍图片的位图像素个数则是4个物理像素，所以它的**取色也只能通过算法进行缩减**，显示结果只有原图像素总数四分之一，肉眼看上去虽然图片不会模糊，但是会觉得有点色差。（其实就是模糊的逆向过程）

    ![gU93wV.png](https://z3.ax1x.com/2021/05/11/gU93wV.png)

##### 1.6 DPR 与 PPI | DPI 的关系

由安卓和苹果的密度分界（**160**），可得DPR与PPI的关系
$$
DPR = \frac{PPI}{160}
$$

##### 1.7 设备像素与CSS像素之间的关系

$$
DPR = \frac{设备像素}{CSS像素}
$$

 获得设备像素比（dpr）后，便可得知设备像素与CSS像素之间的比例。

当比例1:1时，1个设备像素显示1个CSS像素；

当比例2:1时，4（2 * 2）个设备像素显示1个CSS像素；

当比例3:1时，9（3 * 3）个设备像素显示1个CSS像素；

##### 1.8 pt & dp

+ **pt**

  初代iphone像素密度是163ppi，iPhone4像素密度是326ppi。

  1px在初代iphone和iphone4下显示尺寸不相等。

  iphone开发者提出了一个pt的概念，用初代iphone 1px的大小作为基准，记作**1pt**（point），也就是说1pt在iphone4下的大小=2px的宽高。

+ **dp**

  Android也遇到了同样的问题，google提出的解决方案是dp（Density-Independent Pixels），基准是**160ppi**下的1px代表的尺寸，记作**1dp**。

pt和dp起着同样的作用，就是把它当做设计和显示的基本单位，避免使用px引发适配问题。

##### 1.9 pt、dp与px之间的关系

设计图都是按照pt来设计的， 设计图的标准是：x1，x2和x3，也就是设计图的像素为320x480，750x114，1242x2208，但是由于工艺原因，iphone6+的物理像素（分辨率）达不到1242x2208，所以只能做一次**采样处理**（并非缩放，因为显示尺寸并没有变化，还是5.5 inch），显示效果可能比真实的设计图差一点，但是本身分辨率已经很高了。

#### 2. 屏幕

##### 2.1 屏幕尺寸( Screen size )

![gerkyF.jpg](https://z3.ax1x.com/2021/05/03/gerkyF.jpg)

+ **screen.width**

  设备的屏幕的完整宽度，单位为px。

+ **screen.height**

  设备的屏幕的完整高度，单位为px。

+ IE8里，不管使用IE7模式还是IE8模式，都以CSS的pixels来度量。

screen.width 和 screen.height这两个属性值不会因缩放而发生改变，因为他们是**显示器的特征**，而不是浏览器。

##### 2.2 浏览器尺寸 (Window size)

​	浏览器尺寸定义了当前用户有多大区域，**可供css布局占用**。浏览器的**窗口大小**的变化和**用户的缩放**都对css布局占用有影响。

![gerFQU.jpg](https://z3.ax1x.com/2021/05/03/gerFQU.jpg)

+ **window.innerWidth / Height**

  获取当前浏览器窗口宽度 / 高度(包含滚动条)。

+ 兼容性

  IE不支持，Opera用设备pixels来度量。

##### 2.3 滚动移位 (Scrolling offset)

定义页面(document)相对于窗口原点的水平、垂直方向的偏移。能获得某一个方向滚动条的滚动距离。该属性用px来度量。

![gmKMee.jpg](https://z3.ax1x.com/2021/05/03/gmKMee.jpg)

当用户改变浏览器窗口大小时，页面也是会发生滚动移位。但是浏览器会尝试保存用户当前的可见页面依然在可见位置，虽然该特性表现得不如预期，但理论上，滚动移动的偏移量没有改变，偏移出浏览器可见区的css像素大小几乎不变。

![gmKQdH.jpg](https://z3.ax1x.com/2021/05/03/gmKQdH.jpg)

+ **window.pageXOffset **
  **window.scrollX **
  **document.documentElement.scrollLeft (right) **
  **document.body.scrollLeft(right)**

  页面横向滚动移动的偏移量

+ **window.pageYOffset 
  window.scrollY **
  **document.documentElement.scrollTop(bottom) **
  **document.body.scrollTop(bottom)**

  页面横向滚动移动的偏移量

+ 兼容性

  + window.pageXOffset / window.pageYOffset：除IE(6-8)外，都支持
  + window.scrollX / window.scrollY：除IE(6-8)外，IE(9-11)部分支持(最好用pageXOffset/pageYOffset代替)，其余都支持

  + document.documentElement.scrollTop(bottom)：都支持

  + document.body.scrollTop(bottom)：主要兼容**没有doctype声明（quirk模式）**的页面，有doctype声明的页面会为**" 0 "**。

  兼容写法

  ```javascript
  const scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrolltop
  ```

#### 3. Viewport (视口）

![gMA8ht.jpg](https://z3.ax1x.com/2021/05/05/gMA8ht.jpg)

##### pc端

+ 在pc端，viewport为当前浏览器**可视窗口**。

+ viewport用于控制网页最高块状容器：`<html>`。`<html>`**宽度**是受viewport限制，在`<html>`未设置宽度的情况下，默认为`viewport`的宽度。

+ **`<html>`内容发生溢出**：页面的缩放会导致可视窗口(viewport)发生变化，放大可视viewport会变小，如果`<html>`宽为100%，那`<html>`的内部元素可能会发生溢出现象。

+ **获取viewport的尺寸**

  + **window.innerWidth / Height**

    + 包含滚动条

  + **document.documentElement.clientWidth / Height**

    + 不包含滚动条

    + `document.documentElement.clientWidth / Height`给出的尺寸**不受**`<hrml>`的尺寸影响

      ![gMLub8.jpg](https://z3.ax1x.com/2021/05/06/gMLub8.jpg)

      + document.documentElement实际上是`<html>`，但viewport比`<html>`要高一级，它包含`<html>`。如果给`<html>`设置宽度（有效，但不推荐），`document.documentElement.clientWidth/Height`依然是viewport的尺寸，不是`<html>`的尺寸。（这个特殊情况只存在`document.documentElement / <html>`，其他还是实际尺寸）

  + **document.body.clientWidth / Height**

+ **获取`<html>的尺寸`**

  + **document.documentElement.offsetWidth / Height**

    ![gML3Cj.jpg](https://z3.ax1x.com/2021/05/06/gML3Cj.jpg)

+ **事件坐标**

  鼠标事件产生的属性：

  + **pageX / Y**

    点击位置相对于`<html>`的位置信息，单位px。

    ![gMLWVO.jpg](https://z3.ax1x.com/2021/05/06/gMLWVO.jpg)

    ```js
    document.documentElement.addEventListener('click', event => {
        console.log(event.pageX);
        console.log(event.pageY);
    })
    ```

  + **clientX / Y**

    点击位置相对于视口的位置信息，单位px。

    ![gMOzTO.jpg](https://z3.ax1x.com/2021/05/06/gMOzTO.jpg)

    ```js
    document.documentElement.addEventListener('click', event => {        
        console.log(event.clientX);
        console.log(event.clientY);
    })
    ```

  + **screenX / Y**

    点击位置相对于屏幕的位置信息，单位px。

    ![gMXpkD.jpg](https://z3.ax1x.com/2021/05/06/gMXpkD.jpg)

    ```js
    document.documentElement.addEventListener('click', event => {        
        console.log(event.screenX);
        console.log(event.screenY);
    })
    ```

##### 移动端

移动端浏览器通常宽度是 240px~640px，而大多数为 PC 端设计的网站宽度至少为 800px，如果仍以浏览器窗口作为视口的话，网站内容在手机上看起来会非常挤。

因此，引入了布局视口、视觉视口和理想视口三个概念，**使得移动端中的视口与浏览器宽度不再相关联**。

**移动端分为三种viewport**

+ **布局视口（layout viewport）**

  ![g8QCnJ.png](https://z3.ax1x.com/2021/05/08/g8QCnJ.png)

  移动设备的浏览器都默认设置了一个`<meta name="viewport" content="width=980">`，定义一个虚拟的布局视口（layout viewport），用于PC上的网页基本能在移动设备上呈现，但是元素显示很小，需要用户手动缩放。

  + **获取布局视口**

    **document.documentElement.clientWidth / Height**

  + **设置布局视口**

    ```html
    // 设置布局视口为400px, 注意400不加'px'
    <meta name="viewport" content="width=400">
    ```

  布局视口使视口与移动端浏览器屏幕宽度完全独立开。CSS 布局将会根据它来进行计算，并被它约束。

  + 一些设备上浏览器的默认layout viewport的宽度：

    ![g8ldxO.jpg](https://z3.ax1x.com/2021/05/08/g8ldxO.jpg)

+ **视觉视口（visual viewport）**

  视觉视口是用户当前看到的区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口。

  + **获取视觉视口**
    
    **window.innerWidth**
    
  + **视觉视口和缩放比例的关系**：
    $$
    当前缩放值 = \frac{理想视口宽度}{视觉视口宽度}
    $$

  + **移动设备浏览器渲染网页的过程**

    1. 渲染：将整个页面渲染在一个layout viewport中，以保证页面排版正确。
    2. 缩放：将整个layout viewport缩放到visual viewport大小，以保证页面在手机屏幕上被完整显示出来

+ **理想视口（ideal viewport）**

  理想视口( ideal viewport)通常是我们说的屏幕分辨率。它对应的像素叫做**设备独立像素**（device independent pixel, dip）。

  理想视口( ideal viewport)的尺寸在每一个设备上都是不同的。

  eg：iphone6的设备独立像素 375 x 667

  ​	![g81jht.png](https://z3.ax1x.com/2021/05/08/g81jht.png)
  
  **dip / pt / dp 和设备的物理像素无关**，一个 dip / pt / dp 在任意像素密度的设备屏幕上都占据相同的空间。如果用户没有进行缩放，那么一个 CSS 像素就等于一个 dip。
  $$
  ideal viewport的宽度 = 屏幕的逻辑像素宽度
  $$

  + **设置布局视口与理想视口的宽度一致**
  
    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    ```

  + 引入理想视口的目的
  
    布局视口的默认宽度并不是一个理想的宽度，理想视口对设备而言是最理想的布局视口尺寸，用户无需缩放就可以在设备呈现最理想的网页宽度。这就是响应式布局的基础。
    
  + 获取理想视口的尺寸
  
    + **document.documentElement.clientWidth / Height**
  
      使用这个的前提是：
  
      ```html
      <meta name="viewport" content="width=device-width,initial-scale=1.0">
      ```
  
    + **screen.width / height**

#### 4. 视口的设置

+ 使用`<meta name = 'viewport' content = "....">`来进行布局视口的设置。**viewport 只对移动端浏览器有效**，对 PC 端浏览器是无效的。、

+ 在移动端不设置`<meta name = 'viewport' content = "....">`浏览器默认的layout viewport宽度值为：

  ![g8ldxO.jpg](https://z3.ax1x.com/2021/05/08/g8ldxO.jpg)

  不是设置会按默认值将一个PC的页面在移动设备上会进行缩放并完整显示出来

+ content里每个属性说明

  |    属性名     | 取值                       | 描述                                                         |
  | :-----------: | -------------------------- | ------------------------------------------------------------ |
  |     width     | 正整数 \| **device-width** | 设置布局视口的宽度，单位px                                   |
  |    height     | 正整数 \| device-height    | 设置布局视口的高度，未被任何浏览器使用                       |
  | initial-scale | [0.0 - 10.0]               | 初始缩放值                                                   |
  | minimum-scale | [0.0 - 10.0]               | 允许用户的最小缩放值，它必须小于或等于maximum-scale设置，iOS 10 后，Safari 默认忽略此规则 |
  | maximum-scale | [0.0 - 10.0]               | 允许用户的最大缩放值，它必须大于或等于minimum-scale设置，iOS 10 后，Safari 默认忽略此规则 |
  | user-scalable | no \| yes                  | 是否允许用户进行缩放，默认"yes"，iOS 10 后，Safari 默认忽略此规则 |
  | viewport-fit  | auto \| contain \| cover   | 设置可视区域的尺寸，默认为 contain                           |

  + **width=device-width**

    设置布局视口的宽 = 理想视口的宽

    + 设置`width=device-width`这条规则实际上做了如下2件事：

      1. 设置布局视口的宽 = 设备屏幕的宽度(屏幕的逻辑像素宽度,单位px)
      2. 设置理想视口的宽 = 布局视口的宽

    + 移动前端最佳实践

      viewport的宽度 = 布局视口的宽度 = 设备宽度(device-width)

  + **initial-scale**

    + **缩放**：决定能放大或缩小的是缩放因子。

      + 获取缩放因子

        缩放因子是无法直接获取，首先需获得视觉视口的宽，它与缩放因子呈反比，缩放因子越大，视觉视口的宽度越小。缩放因子决定最大视觉视口的宽度。
        $$
        当前缩放值 = \frac{理想视口宽度}{视觉视口宽度}
        $$
        缩放因子与ideal viewport存在关系，而不论当时layout viewport的大小是多少。

    + 设置 initial-scale这条规则实际上做了如下2件事：

      1. 根据initial-scale的初始值，计算出相对于理想视口的视觉视口的宽
      2. 设置布局视口的宽 = 视觉视口的宽

  + **定义宽度规则时的冲突**

    同时设置`initial-scale`和`width`可能出现冲突，浏览器处理这个冲突方法是：**宽度最大优先原则**(横屏或竖屏模式下均是)。

    以iphone 4s为例：`<meta name="viewport" content="initial-scale=1,width=400">`

    initial-scale设置布局视口为320px，width设置布局视口为400px。最终浏览器的布局视口为400px。

  + **设置布局视口的宽等于理想视口**

    **width=device-width** | **initial-scale=1.0** 都可以设置布局视口，但各有缺陷

    + width=device-width：在IPhone和IPad上存在兼容问题
    + initial-scale=1.0：在IE上存在兼容问题

    **兼容设置：同时设置 width=device-width & initial-scale=1.0**

    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    ```

  + **maximum-scale / minimum-scale**

    + iOS 中 所有 Web 容器均无法缩放 到 比 initial-scale 更小的倍数，即使 minimum-scale 声明了一个更小且合理的取值。
    + iOS 微信(7.0.5)的 webview 中，遵守了最大 3 倍声明，但 Safari 可以放大到比 3 倍更高的倍数。
    + iOS10 开始，为了提高网页在 Safari 中的可访问性，Safari内无效了。

  + **user-scalable = no**

    + Safari 中依然无法缩小可以放大，微信中无法缩放；
    + user-scalable，iOS10 开始，无效了。
    + 从`Chrome32+`版本开始是会默认禁用用户缩放的，但是考虑到兼容大部分设备，还是要加上，让`meta`标签能够有更好的容错性。

  + **viewport-fit**

    此属性为 2017 年 Apple 为了解决 iPhoneX 手机的**刘海屏问题**，增加的新属性。[详细介绍跳转到刘海屏、水滴屏适配](#刘海屏、水滴屏适配)

  ##### 移动端视口设置

  ```html
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
  ```

#### 一倍图、二倍图、三倍图的CSS适配

#### 特殊机型适配

##### 刘海屏、水滴屏适配

##### iPhoneX刘海屏适配方案

###### 方案一

###### 方案二

